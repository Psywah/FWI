// Trapping problems (heterogeneous)

// Command line flags:
//  -waven              default = 18.5    - Wavenumber k
//  -cmin               default = 1       - Minimum wave speed
//  -cmax               default = 10      - Maximum wave speed
//  -nloc               default = 20      - Mesh parameter
//  -radius             default = 0.25    - obstacle raduis
/*  -DCType=6           default 6         - wave speed type
           =0: wave speed c = 1
           =1: circle obstacle, c decreases from center to boundary 
           =2: circle obstacle, c increases from center to boundary 
           =3: circle obstacle, c oscilates 
           =4: square obstacle, c decreases from center to boundary 
           =5: square obstacle, c increases from center to boundary 
           =6: square obstacle, c oscilates 
*/

include "getARGV.idp"
// Problem parameters               // Omega = unit square
real k = getARGV("-waven",18.5);    // wave number without dividing by c
func f = 0;                         // source function
func g = 0;                         // Dirichlet BC
real d1= sqrt(1./2), d2=sqrt(1./2); // direction of incomming wave
func Nx = N.x;
func Ny = N.y;
func gn = 1i*k*(d1*Nx+d2*Ny +1)*exp(1i*k*(d1*x+d2*y)); // Robin BC


real cmax = getARGV("-cmax", 2.5);      // maximal wave speed
real cmin = getARGV("-cmin", 0.5);      // minimal wave speed
real radius =getARGV("-radius", 0.25);  // obstacle radius
// wave velocity and print the problem name
IFMACRO(!CType)
    macro CType 0 //
ENDIFMACRO
IFMACRO(CType, 0)
    func c = 1;
    cout << endl << " Problem: homogeneous problem with c = 1"<<endl<<endl;
ENDIFMACRO


IFMACRO(CType, 1) //decrease
    func innerCir = sqrt((x-.5)^2+(y-.5)^2) <= radius;
    func dist = radius -sqrt((x-.5)^2+(y-.5)^2);
    func c = 1. + innerCir *dist*4 * (cmax -cmin)-innerCir*(1-cmin)  ;
    cout << endl << "Problem: Trapping problem with circle obstacle "<< endl<< "                       "
                  + "and with linearly varying c from cmax ("
                 << cmax <<" center), cmin (" << cmin << " interface)" << endl << endl;
ENDIFMACRO
IFMACRO(CType, 2) //increase
    func innerCir = sqrt((x-.5)^2+(y-.5)^2) <= radius;
    func dist = radius -sqrt((x-.5)^2+(y-.5)^2);
    func c = 1. - innerCir *dist*4 * (cmax -cmin) +innerCir*(cmax -1)  ;
    cout << endl << "Problem: Trapping problem with circle obstacle "<< endl<< "                       "
                  + "and with linearly varying c from cmin ("
                 << cmin <<" center), cmax (" << cmax << " interface)" << endl << endl;
ENDIFMACRO
IFMACRO(CType, 3) // oscilate
    func innerCir = sqrt((x-.5)^2+(y-.5)^2) <= radius;
    func dist = (radius -sqrt((x-.5)^2+(y-.5)^2))/radius*7;
    func c = 1. + innerCir* (floor(dist)%2 *(cmax -cmin) +cmin -1);
    cout << endl << "Problem: Trapping problem with circle obstacle "<< endl<< "                       "
                   + "and with oscilating c between cmin ("
                 << cmin <<"), cmax (" << cmax << ")" << endl << endl;
ENDIFMACRO


IFMACRO(CType, 4)
    func innerBox = 0.5-radius<=x &&0.5+radius >=x && 0.5-radius<=y && 0.5+radius>=y ;
    func dist = min(min(x-0.5+radius, 0.5+radius-x), min(y-0.5 +radius, 0.5+radius-y));
    func c = 1. + innerBox *dist*4 * (cmax -cmin)-innerBox*(1-cmin)  ;
    cout << endl << "Problem: Trapping problem with square obstacle "<< endl<<  "                       "
                    +"and with linear varying c from cmax ("
                 << cmax <<" center), cmin (" << cmin << " interface)" << endl << endl;
ENDIFMACRO
IFMACRO(CType, 5)
    func innerBox = 0.5-radius<=x &&0.5+radius >=x && 0.5-radius<=y && 0.5+radius>=y ;
    func dist = min(min(x-0.5+radius, 0.5+radius-x), min(y-0.5 +radius, 0.5+radius-y));
    func c = 1. - innerBox *dist*4 * (cmax -cmin) +innerBox*(cmax -1)  ;
    cout << endl << "Problem: Trapping problem with square obstacle "<< endl<< "                       "
                    +"and with linear varying c from cmin ("
                 << cmin <<" center), cmax (" << cmax << " interface)" << endl << endl;
ENDIFMACRO
IFMACRO(CType, 6)
    func innerBox = 0.5-radius<=x &&0.5+radius >=x && 0.5-radius<=y && 0.5+radius>=y ;
    func dist = min(min(x-0.5+radius, 0.5+radius-x), min(y-0.5 +radius, 0.5+radius-y))/radius*7;
    func c = 1. + innerBox* (floor(dist)%2 *(cmax -cmin) +cmin -1);
    cout << endl << "Problem: Trapping problem with square obstacle "<< endl<< "                      "
                    +"and with oscilating c between cmin ("
                 << cmin <<"), cmax (" << cmax << ")" << endl << endl;
ENDIFMACRO

// Boundary conditions
int Dirichlet = 1;
int Robin = 2;
int[int] chlab=[1, Robin, 2, Robin, 3, Robin, 4, Robin];

// Create mesh
int nsubdom = 5;
int nloc = getARGV("-nloc",20);
mesh Thc = square(nsubdom,nsubdom,flags=1);
Thc = change(Thc,refe=chlab);
mesh Th = trunc(Thc,1,split=nloc);


